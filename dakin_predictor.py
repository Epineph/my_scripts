#!/usr/bin/env python3
# dakin_predictor.py
"""
Dakin reaction forward predictor (template + heuristic).
Given an aryl aldehyde or aryl ketone (SMILES) and basic H2O2 conditions,
apply the Dakin transformation to produce the phenol + carboxylic acid,
and score the plausibility of the chosen conditions.

LIMITATIONS
- RDKit template: structure-only; no ab initio kinetics.
- The "feasibility score" is a transparent rule-of-thumb, not a ML model.
- Assumes alkaline peroxide (e.g., NaOH + H2O2) in protic solvent.

USAGE
  ./dakin_predictor.py --smiles "O=CC1=CC=CC=C1" \
      --temp 40 --time_h 4 --base NaOH --base_eq 2.0 \
      --peroxide_eq 2.0 --solvent "MeOH/H2O" --conc_M 0.2

EXAMPLES
  # p-hydroxybenzaldehyde
  ./dakin_predictor.py --smiles "O=CC1=CC=C(O)C=C1" --temp 30 --time_h 2 \
      --base NaOH --base_eq 2.0 --peroxide_eq 2.0 --solvent "EtOH/H2O" --conc_M 0.1

  # aryl methyl ketone
  ./dakin_predictor.py --smiles "CC(=O)C1=CC=CC=C1" --temp 50 --time_h 6 \
      --base KOH --base_eq 3.0 --peroxide_eq 3.0 --solvent "MeOH/H2O" --conc_M 0.2
"""
import argparse, sys
from rdkit import Chem
from rdkit.Chem import AllChem

def parse_args():
    p = argparse.ArgumentParser(add_help=True)
    p.add_argument("--smiles", required=True, help="Reactant SMILES (aryl aldehyde/ketone)")
    p.add_argument("--temp", type=float, default=25.0, help="Temperature (°C)")
    p.add_argument("--time_h", type=float, default=4.0, help="Reaction time (hours)")
    p.add_argument("--conc_M", type=float, default=0.2, help="Substrate concentration (M)")
    p.add_argument("--base", default="NaOH", help="Base (e.g., NaOH, KOH)")
    p.add_argument("--base_eq", type=float, default=2.0, help="Equivalents of base")
    p.add_argument("--peroxide_eq", type=float, default=2.0, help="Equivalents of H2O2")
    p.add_argument("--solvent", default="MeOH/H2O", help="Solvent system")
    p.add_argument("--svg", action="store_true", help="Emit SVG depictions (RDKit)")
    return p.parse_args()

# SMARTS: aryl aldehyde and aryl ketone motifs
ALD_PATTERN = Chem.MolFromSmarts("[c:ar][C:acyl](=O)[H]")
KET_PATTERN = Chem.MolFromSmarts("[c:ar][C:acyl](=O)[#6:rk]")

# Dakin transformations as reaction SMARTS
# Aldehyde: Ar-CHO → Ar-OH + HCOOH
RXN_ALD = AllChem.ReactionFromSmarts("[c:ar][C:acyl](=O)[H:hid]>>[c:ar]O.O=[C:acyl]O")
# Ketone: Ar-CO-R → Ar-OH + R-COOH
RXN_KET = AllChem.ReactionFromSmarts("[c:ar][C:acyl](=O)[#6:rk]>>[c:ar]O.[#6:rk][C:acyl](=O)O")

EDG_SMARTS = [
    "[cH0]O",     # phenolic OH
    "[cH0]N",     # anilines (broad)
    "[cH0]OC",    # anisole-type
]
EWG_SMARTS = [
    "[cH0]N(=O)=O",  # nitro
    "[cH0]C#N",      # cyano
    "[cH0]C(=O)",    # acyl, ester, amide directly on ring
    "[cH0]S(=O)(=O)",# sulfone/sulfonyl
    "[cH0]C(F)(F)F", # CF3
]

def count_matches(mol, smarts_list):
    return sum(mol.HasSubstructMatch(Chem.MolFromSmarts(s)) for s in smarts_list)

def classify_substrate(mol):
    is_ald = mol.HasSubstructMatch(ALD_PATTERN)
    is_ket = mol.HasSubstructMatch(KET_PATTERN)
    return ("aldehyde" if is_ald else "ketone" if is_ket else None)

def heuristic_score(kind, mol, temp, time_h, base_eq, perox_eq, conc_M):
    score = 0.0
    # Substrate reactivity
    if kind == "aldehyde": score += 0.30
    if kind == "ketone":   score += 0.10
    edg = count_matches(mol, EDG_SMARTS)
    ewg = count_matches(mol, EWG_SMARTS)
    score += 0.20 * min(edg, 2)   # EDG helps
    score -= 0.15 * min(ewg, 2)   # EWG hurts
    # Conditions (typical windows)
    if 20 <= temp <= 60: score += 0.15
    if 1.5 <= base_eq <= 3.5: score += 0.10
    if 1.5 <= perox_eq <= 3.5: score += 0.10
    if 0.05 <= conc_M <= 0.5: score += 0.05
    if time_h >= 1: score += 0.05
    # Clamp to [0,1]
    return max(0.0, min(1.0, score))

def depict_svg(mols):
    from rdkit.Chem.Draw import MolsToGridImage
    return MolsToGridImage(mols, subImgSize=(250,250), useSVG=True)

def main():
    args = parse_args()
    mol = Chem.MolFromSmiles(args.smiles)
    if mol is None:
        sys.exit("ERROR: cannot parse SMILES.")
    kind = classify_substrate(mol)
    if kind is None:
        sys.exit("ERROR: Not an aryl aldehyde/ketone (as recognized by the simple patterns).")

    rxn = RXN_ALD if kind == "aldehyde" else RXN_KET
    prods_sets = rxn.RunReactants((mol,))
    if not prods_sets:
        sys.exit("No products generated by the Dakin template. (Check SMARTS or input.)")

    # Choose the first product set
    prods = [Chem.MolToSmiles(Chem.Mol(prods_sets[0][i]), isomericSmiles=True)
             for i in range(len(prods_sets[0]))]

    score = heuristic_score(kind, mol, args.temp, args.time_h, args.base_eq, args.peroxide_eq, args.conc_M)

    print("== INPUT ==")
    print(f"SMILES: {args.smiles}")
    print(f"Classified: {kind}")
    print(f"Conditions: T={args.temp} °C, t={args.time_h} h, conc={args.conc_M} M, base={args.base} "
          f"({args.base_eq} eq), H2O2={args.peroxide_eq} eq, solvent={args.solvent}")
    print("\n== PREDICTED PRODUCTS (template) ==")
    for i, s in enumerate(prods, 1):
        print(f"  P{i}: {s}")
    print("\n== FEASIBILITY SCORE (0–1; higher is better) ==")
    print(f"  {score:.2f}")
    print("Notes: EDG ortho/para to acyl increases score; strong EWG decreases it. "
          "Aldehydes generally score higher than ketones. Score is heuristic only.")

    if args.svg:
        try:
            svgs = depict_svg([mol] + [Chem.MolFromSmiles(s) for s in prods])
            with open("dakin_output.svg", "w") as f:
                f.write(svgs)
            print("\nWrote depiction to dakin_output.svg")
        except Exception as e:
            print(f"\n[SVG depiction failed: {e}]")

if __name__ == "__main__":
    main()
